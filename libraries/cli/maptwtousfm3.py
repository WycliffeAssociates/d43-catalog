#!/usr/bin/env python2
# -*- coding: utf-8 -*-

"""
This tool reads USFM files generated by csvtousfm3.py
and injects tW links into the matching Greek or Hebrew words.

Errors are recorded in errors.log in the output directory.

Assumptions:
1. The tW RC contains a list of occurrences for each word.
2. This list of occurrences is stored in the config.yaml file.
3. The word content contains a #2 heading titled "Word Data" under which are strong's numbers.
"""

import argparse
import os
import sys
import re
import logging

from resource_container import factory, ResourceContainer
from libraries.tools.file_utils import write_file, read_file

LOGGER_NAME='map_tw_to_usfm'

def indexWords(words_rc):
    """
    Generates an index of word occurrences where words may be looked up by
    textual occurrence.
    :param words_rc:
    :type words_rc: ResourceContainer.RC
    :return: a dictionary of words keyed by location
    """
    logger = logging.getLogger(LOGGER_NAME)
    index = {}
    config = words_rc.config()
    for word in config:
        word_obj = config[word]
        if 'occurrences' in word_obj:
            for location in word_obj['occurrences']:
                try:
                    parts = location.split('/')
                    length = len(parts)
                    verse = _unzpad(parts[length-1])
                    chapter = _unzpad(parts[length-2])
                    book = parts[length - 3]
                    location = '{}/{}/{}'.format(book, chapter, verse)
                    if location in index:
                        # append to index
                        index[location].append(word)
                    else:
                        # create index
                        index[location] = [word]
                except Exception as e:
                    logger.error('Failed to parse location: {}'.format(location))
                    raise e
    return index

def _unzpad(strint):
    """
    Removes zpadding from an integer string
    :param strint: a string that contains an integer value
    :return:
    """
    return '{}'.format(int(strint))

def loadStrongs(word, words_rc):
    """
    Retrieves the strong numbers for a word from it's data file
    :param word: the word to index
    :param words_rc:
    :type words_rc: ResourceContainer.RC
    :return: a list of strongs
    """

    # TRICKY: the config.yaml does not provide sufficient information to
    # locate the word, however we only have 3 options.
    # There should not be any duplicates within these folders.
    logger = logging.getLogger(LOGGER_NAME)

    numbers = []
    data = words_rc.read_chunk('kt', word)
    if not data:
        data = words_rc.read_chunk('names', word)
    if not data:
        data = words_rc.read_chunk('other', word)
    if not data:
        # TRICKY: ignore missing words. The config.yaml file was inaccurate
        return numbers

    header = re.findall('^#+\s*Word\s+Data\s*\:?.*', data, re.MULTILINE|re.IGNORECASE)
    if(len(header)):
        word_data = data.split(header[0])[1]
        numbers = re.findall('[HG]\d+', word_data, re.MULTILINE | re.IGNORECASE)
    else:
        category = _getWordCategory(word, words_rc)
        logger.error('Missing Word Data section in word "{}/{}"'.format(category, word))

    return numbers

def _getWordCategory(word, words_rc):
    """
    Retrieves the category of a word
    :param word:
    :param words_rc:
    :type words_rc: ResourceContainer.RC
    :return:
    """
    # TRICKY: the config.yaml does not provide enough information for us to backtrack words.
    # however, we know there are only 3 locations
    categories = ['kt', 'names', 'other']
    for cat in categories:
        if '{}.md'.format(word) in words_rc.chunks(cat):
            return cat
    return None

def _makeWordLink(word, words_rc):
    """
    Generates a language agnostic link to a tW
    :param word:
    :param words_rc:
    :type words_rc: ResourceContainer.RC
    :return: a new rc link
    """
    category = _getWordCategory(word, words_rc)
    if not category:
        raise Exception('Failed to look up category for word {}'.format(word))

    return 'rc://*/tw/dict/bible/{}/{}'.format(category, word)

def _getWords(location, words_index):
    """
    Retrieves the words found at the passage location
    :param location: The passage location e.g. book/chapter/verse without z-padding
    :param words_index:
    :return: a list of words
    """
    if location in words_index:
        return words_index[location]
    else:
        return []

def indexStrongs(location, words_index, words_rc, strongs_index=None):
    """
    Generates an index of strong numbers associated with a word found in the given location.
    If the existing index is provided this may not hit the filesystem.
    :param location:
    :param words_index:
    :param words_rc:
    :param strongs_index: the existing index. This will be updated if set
    :return: a dictionary of strong numbers keyed by word
    """
    words = _getWords(location, words_index)
    if strongs_index:
        index = strongs_index
    else:
        index = {}

    for word in words:
        if word not in index:
            index[word] = loadStrongs(word, words_rc)
    return index

def getStrongs(word, strongs_index):
    """
    Retrieves the strongs found for a word
    :param word:
    :param strongs_index:
    :return: a list of strong numbers
    """
    if word in strongs_index:
        return strongs_index[word]
    else:
        return []

def mapWord(strong_number, words, strongs_index):
    """
    Returns a word that is mapped to the strong's number
    :param strong_number:
    :param words: a list of words available for mapping. These are available based on the passage location.
    :param strongs_index: an index of strong's numbers from which to read
    :return: the word or None
    """
    for word in words:
        strongs = getStrongs(word, strongs_index)
        for strong in strongs:
            # TRICKY: reverse zero pad numbers from the index to match the length
            formatted_strong = (strong + '000000')[:len(strong_number)]
            if formatted_strong.lower() == strong_number.lower():
                return word
    return None

# TRICKY: we purposely make strongs_index a mutable parameter
# this allows us to maintain the strong's index.
def mapUSFM(usfm, words_rc, words_index, strongs_index={}):
    """
    Injects tW links into the usfm.
    If you are operating on multiple files you can
    :param usfm:
    :type usfm: basestring
    :param words_rc:
    :type words_rc: ResourceContainer.RC
    :param words_index: the index of words keyed by location.
    :param strongs_index: the index of word strong numbers.
    :return: the newly mapped usfm
    """
    logger = logging.getLogger(LOGGER_NAME)
    lines = usfm.splitlines()
    line = ''
    book = None
    chapter = None
    verse = None
    header = []

    # locate book id
    while not book and not line.startswith('\\c ') and len(lines):
        line = lines.pop(0)
        header.append(line)
        if line.startswith('\\id'):
            # get id
            match = re.findall('^\\\id\s+(\w+)\s+.*', line, re.IGNORECASE|re.UNICODE)
            if match and len(match):
                book = match[0].lower()
            else:
                raise Exception('Malformed USFM. Unable to parse book id: {}'.format(line))

    if not book:
        raise Exception('Malformed USFM. Could not find book id.')

    for index, line in enumerate(lines):
        strong = None

        # start chapter
        if re.match(r'\\c\b', line):
            match = re.findall(r'^\\c\s+(\d+)', line, re.IGNORECASE|re.UNICODE)
            if match and len(match):
                chapter = _unzpad(match[0])
                verse = None
            else:
                raise Exception('Malformed USFM. Unable to parse chapter number: {}'.format(line))

        # start verse
        if re.match(r'\\v\b', line):
            match = re.findall(r'^\\v\s+(\d+)', line, re.IGNORECASE|re.UNICODE)
            if match and len(match):
                verse = _unzpad(match[0])
            else:
                raise Exception('Malformed USFM. Unable to parse verse number: {}'.format(line))

        # start original language word
        if re.match(r'\\w\b', line):
            match = re.findall(r'strong="([\w]+)"', line, re.IGNORECASE|re.UNICODE)
            if match and len(match):
                strong = match[0]
            else:
                raise Exception('Malformed USFM. Unable to parse strong number: {}'.format(line))

        # map word
        if chapter and verse and strong:
            location = '{}/{}/{}'.format(book, chapter, verse)
            words = _getWords(location, words_index)
            strongs_index = indexStrongs(location, words_index, words_rc, strongs_index)
            word = mapWord(strong, words, strongs_index)
            if word:
                # inject link at end
                link = 'x-tw="{}"'.format(_makeWordLink(word, words_rc))
                lines[index] = line.replace('\w*', ' ' + link + ' \w*')
            elif len(words):
                pass
                # logger.warning('No match found for {} at {}'.format(strong, location))
        elif line.startswith('\\w'):
            raise Exception('Malformed USFM. USFM tags appear to be out of order.')

    return '\n'.join(header + lines)

def mapDir(usfm_dir, words_rc, output_dir):
    """

    :param usfm_dir: a directory containing USFM files generated by `csvtousfm3`
    :param words_rc: the tW resource container
    :type words_rc: ResourceContainer.RC
    :param output_dir: a directory where the newly mapped usfm will be saved
    :return:
    """
    usfm_files = []
    words_index = {}
    for root, dirs, files in os.walk(usfm_dir):
        usfm_files.extend(files)
        print('Generating tW index')
        words_index = indexWords(words_rc)
        break

    for file_name in usfm_files:
        if not file_name.endswith('.usfm'):
            continue

        file = os.path.join(usfm_dir, file_name)
        print('{}'.format(file_name))
        usfm = mapUSFM(read_file(file), words_rc, words_index)
        outfile = os.path.join(output_dir, os.path.basename(file))
        write_file(outfile, usfm)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description=__doc__,
                                   formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument('-u', '--usfm', dest='usfm', required=True, help='Directory containing USFM files to read')
    parser.add_argument('-w', '--words', dest='words', required=True, help='tW resource container to read. You can download one from https://git.door43.org/Door43/en_tw')
    parser.add_argument('-o', '--output', dest='output', required=True, help='Director to which the updated USFM will be saved')

    args = parser.parse_args(sys.argv[1:])
    if os.path.isfile(args.output):
        raise Exception('Output must be a directory')

    rc = factory.load(args.words)

    errors_log_file = os.path.join(args.output, 'errors.log')
    if os.path.isfile(errors_log_file):
        os.remove(errors_log_file)

    # configure logger
    logger = logging.getLogger(LOGGER_NAME)
    logger.setLevel(logging.WARNING)
    handler = logging.FileHandler(errors_log_file)
    handler.setLevel(logging.WARNING)
    formatter = logging.Formatter("[%(levelname)s] %(message)s")
    handler.setFormatter(formatter)
    logger.addHandler(handler)

    # start
    mapDir(args.usfm, rc, args.output)

    # announce errors or clean up log file
    if os.path.isfile(errors_log_file):
        statinfo = os.stat(errors_log_file)
        if statinfo.st_size > 0:
            print('WARNING: errors were detected. See {} for details'.format(errors_log_file))
        else:
            os.remove(errors_log_file)

    print('Finished')

